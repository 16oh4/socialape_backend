const {db} = require('../util/admin.js'); //.js is optional
const {sucStr, errStr, validateScream} = require('../util/validators')


//admin is kind of like express app instance
//firestore() returns a Firestore instance
//collection('path') returns a CollectionReference
//get(GetOptions) returns a likeQuerySnapshot as a Promise
//      likeQuerySnapshot contains 0 or more screamSnapshot objects in the callback
exports.getAllScreams = (req, res) => {
    db
    .collection('screams')
    .orderBy('createdAt', 'desc')   //sorts the documents by creation date with newest first
    .get()
    .then( data => {
        let screams = [];
        data.forEach( screamSnapshot => {
            screams.push({
                id: screamSnapshot.id,
                ...screamSnapshot.data()
            });
        });
        return res.json(screams);
    })
    .catch( err => {
        console.error(errStr(req, err, 'Could not retrieve data from Firestore'));
    })
};

exports.postOneScream = (req, res) => {
    //do not use quotes around keys because it's not JSON!!

    console.log(`After FBAuth, req is:\n${JSON.stringify(req.user)}`);
    let newScream = { //create a new scream in JSON format
        body: req.body.body,
        userHandle: req.user.handle,
        userImage: req.user.imageUrl,
        likeCount: 0,
        commentCount: 0,
        createdAt: new Date().toISOString(),
    };

    const valid = validateScream(newScream.body);

    if(!valid.valid) {
        return res.status(400).json(valid.errors);
    }

    //CollectionReference.add() takes a new document to add!
    db.collection('screams').add(newScream)
    .then( document => { //returns DocumentReference pointing to newly created document after writing it to backend
        //Once the document is fetched, then we can append id to the returned data
        const resScream = newScream;
        resScream.screamId = document.id;
        res.status(200).json(resScream);
    })
    .catch( error => {
        //return server error because could not create Document in backend
        console.error(errStr(req, err, 'Could not add new scream in Firestore'));
        res.status(500).json(error);
    });    
};

exports.postOneComment = (req, res) => {
    //check if user comment is empty
    if(req.body.body.trim() === '') return res.status(400).json({comment: 'Must not be empty'});

    let newComment = {
        userHandle: req.user.handle,
        userImage: req.user.imageUrl,
        screamId: req.params.screamId,
        body: req.body.body,
        createdAt: new Date().toISOString(),
    };
    
    console.log(`NEW COMMENT:\n${JSON.stringify(newComment)}`);

    //check if scream still exists too!
    let screamId;
    db
    .doc(`/screams/${req.params.screamId}`)
    .get()
    .then(docSnapshot => {
        if(!docSnapshot.exists) {
            return res.status(404).json({message: 'Scream no longer exists!'});
        }
        screamId = docSnapshot.id;
        return docSnapshot.ref.update({ //since we have the DocSnapshot already, can get DocReference to update
            commentCount: (docSnapshot.data().commentCount+1)
        })
    })
    .then(writeResult => {
        // console.log(sucStr(req, `Updated comment count for screamId: ${req.params.id}`));
        // return res.status(200).json({message: "Updated comment count"})
        return db.collection('comments').add(newComment);
    })
    .then(documentRef => {
        //201 is resource created
        console.log(sucStr(req, `Added comment ID: ${documentRef.id} for scream ID ${screamId}`));
        res.status(201).json(newComment);
    })
    .catch(err => {
        console.error(errStr(req, err, 'Could not create document for comment in Firestore'));
        res.status(500).json(err);
    }) 
    
}

exports.getScream = (req, res) => {
    let screamData = {};
    db.doc(`/screams/${req.params.screamId}`).get()
    .then( doc => {
        if(!doc.exists) {
            return res.status(404).json( {error: 'Scream not found'} );
        }
        //By this point, document does exist
        screamData = doc.data();
        screamData.screamId = doc.id; //this is the ID auto-generated by Firestore
        return db
        .collection('comments')
        .orderBy('createdAt', 'desc')
        .where('screamId', '==', screamData.screamId)
        .get(); //search for comments inside screamId
    })
    .then( likeQuerySnapshot => {
        screamData.comments = [];
        likeQuerySnapshot.forEach(doc => {
            screamData.comments.push(doc.data());
        });
        return res.status(200).json(screamData);
    })
    .catch(err => {
        req.route = '/scream/:screamId';
        console.error(errStr(req, err, 'Could not query Firestore for commments matching screamId'));
        res.status(500).json({error: err.code});
    });
}

exports.likeScream = (req, res) => {
    //Need to test if scream is already liked
    //-->Need to check if scream exists first
    //Get both like and scream documents
    const likeDocQuery = 
    db
    .collection('likes')
    .where('userHandle', '==', req.user.handle)
    .where('screamId', '==', req.params.screamId)
    .limit(1);

    const screamDocQuery =
    db
    .doc(`/screams/${req.params.screamId}`);

    let screamData = {};

    screamDocQuery.get() //fetch the scream that will be liked
    .then(screamSnapshot => {
        if(screamSnapshot.exists){ //more efficient to start with case that is most probable to happen to return early
            screamData = screamSnapshot.data(); //store the data of the scream
            screamData.screamId = screamSnapshot.id; //append the screamId to the local data of the scream
            return likeDocQuery.get(); //let's check to see if the user has already liked this scream
        } else {
            return res.status(404).json(`Scream ${screamId} does not exist in Firestore`);
        }
    })
    .then(likeQuerySnapshot => {
        if(likeQuerySnapshot.empty) { //if array is empty, then scream does not have a like from the user yet
            return db.collection('likes').add({ //add like to database now
                screamId: screamData.screamId, 
                userHandle: req.user.handle,
                createdAt: new Date().toISOString()
            })
            .then( () => { //upon sucessful creation of like, Promise returns DocumentReference but don't need it
                //after incrementing likeCount at internal data structure, then reflect in Firestore
                screamData.likeCount++;
                return screamDocQuery.update( {likeCount: screamData.likeCount} )//pre-decrement to reflect original value
            })
            .then( () => { //WriteResult gives more information about the status code of the update
                return res.status(201).json(screamData);
            })
        }
        else { //this means the scream is already liked by the user
            return res.status(400).json({error: 'Scream already liked'});
        }
    })
    .catch( err => {
        console.error(errStr(req, err, 'Failed to query scream/like from Firestore'));
        return res.status(500).json(err);
    })

}

exports.unlikeScream = (req, res) => {
    //Need to test if scream is already liked
    //-->Need to check if scream exists first
    //Get both like and scream documents
    const likeDocQuery = 
    db.collection('likes').where('userHandle', '==', req.user.handle).where('screamId', '==', req.params.screamId).limit(1);

    const screamDocQuery =
    db.doc(`/screams/${req.params.screamId}`);

    let screamData = {};

    screamDocQuery.get() //check to see if the scream exists first
    .then(screamSnapshot => { //sucessfull query from db
        if(screamSnapshot.exists){ //more efficient to start with case that is most probable to happen to return early
            console.log("SCREAM EXISTS");

            screamData = screamSnapshot.data(); //store the data of the scream
            screamData.screamId = screamSnapshot.id; //append the screamId to the local data of the scream

            return likeDocQuery.get(); //now let's check to see if the user has already liked this scream
        } else {
            return res.status(404).json(`Scream ${screamId} does not exist in Firestore`);
        }
    })
    .then(likeQuerySnapshot => { //sucessfull query from db
        console.log("LIKE EXISTS");

        if(likeQuerySnapshot.empty) { //if array is empty, then scream does not have a like from the user yet
            return res.status(400).json({error: 'Scream not liked'});
        }
        else { //this means the scream is already liked by the user
            return db.doc(`/likes/${likeQuerySnapshot.docs[0].id}`).delete() //delete the like!
            .then( writeResult => { //now that it's deleted, need to update scream document
                screamData.likeCount--;
                return screamDocQuery.update({likeCount: screamData.likeCount});
            })
            .then( () => { //sucessfully decremented like count in database
                console.log(sucStr(req, 'Sucessfully unliked scream')) 
                res.status(200).json(screamData);
            })
        }
    })
    .catch( err => { //having a catch statement does not print the error stack trace!!!
        console.error(errStr(req, err, 'Failed to query scream/like from Firestore. Could not unlike scream.'));
        return res.status(500).json(err);
    })
}

exports.deleteScream = (req, res) => {
    const screamDocRef = db.doc(`/screams/${req.params.screamId}`);

    //First get scream data to check if requestor is actually the owner
    screamDocRef.get()
    .then(screamDocSnap => {
        // console.log('In screamDocSnap');
        if(!screamDocSnap.exists) {
            return res.status(404).json( {error: 'Scream does not exist' });
        }
        if(screamDocSnap.data().userHandle !== req.user.handle) {
            //Status 403 is unauthorized
            return res.status(403).json( {error: 'Unauthorized'} );
        } else {
            return screamDocRef.delete();
        }
    })
    .then(() => {
        return res.status(200).json( {message: 'Successfully deleted scream'} );
    })
    .catch( err => {
        console.error(err);
        return res.status(500).json( {error: err.code} );
    })
}